/*
 * author: Rodrigo Caetano (rcor)
 *
 * compile: mpicc factorate_mpz.c ./datatypes/*.c ./time/*.c -o factorate_mpz -lgmp -lrt
 * run: mpiexec -n <number of processors> factorate_mpz
 * 
*/


/*
 Useful MPI procedures.
 int MPI_Send(void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm)
 int MPI_Recv(void *buf, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Status *status)
 int MPI_Bcast( void *buffer, int count, MPI_Datatype datatype, int root, MPI_Comm comm )
*/
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "datatypes/list.h"
#include "time/hr_time.h"

#include <gmp.h>
#include <mpi.h>

void random_number(mpz_t n, int numlen);
void calculate_interval(mpz_t n_interval, int rank, mpz_t n_start, mpz_t n_end );
void print_list(list_t *list);

int main(int argc, char** argv) {
    //declaration of loads of variabels
    hr_timer_t hr_tm;
    int found_divisor = 0;
    int has_breaken = 0;
    int has_finished = 0;
    int rank, nprocs;
    int test = 0;
    int tag = 1234;
    MPI_Status status;
    MPI_Request req;
    mpz_t n; //number
    mpz_t d; //divisor
    mpz_t r; //remainder
    char *nstr;
    int nlen;
    char *dstr;
    int dlen;
    int i;
    int countzeros = 0; //very useful variable to know if all nodes have already finished looking for a divisor
    node_t *node;
    list_t *temp = create_list();
    list_t *factors = create_list();

    MPI_Init(&argc, &argv);
    MPI_Comm_size(MPI_COMM_WORLD, &nprocs);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    
    mpz_init(n); 
    mpz_init(d);
    mpz_init(r);

    if(rank==0){
        nstr = "30020102222000001999447366557956751";
        mpz_set_str(n, nstr, 10); //35
        nlen = strlen(nstr);

        gmp_printf("Number: %Zd\n", n);
        
        
        hrt_start(&hr_tm); //it must be right here
        while(1){
           mpz_mod_ui(r, n, 2);
           if( (mpz_cmp_ui(n,2) > 0) && mpz_sgn(r)==0 ) {
           
              node = alloc_node(sizeof(mpz_t));
              mpz_init(NODEGET( mpz_t, node ));
              mpz_set_ui(NODEGET( mpz_t, node ), 2);
              list_push_back(factors, node);
             
              mpz_cdiv_q_ui(n,n,2);
           }else if(mpz_cmp_ui(n,2) == 0){
              node = alloc_node(sizeof(mpz_t));
              mpz_init(NODEGET( mpz_t, node ));
              mpz_set_ui(NODEGET( mpz_t, node ), 2);
              list_push_back(factors, node);
              nlen = -1;
              break;
           }else {
              nstr = mpz_get_str(NULL, 10, n);
              nlen = strlen(nstr);
              break;
           }
        }
    }
    
    if(1) { //always: don't ask me why I'm using this 'if' xD
       char *nintstr; //interval string
       int  nintlen;  //interval len
       mpz_t n_interval;
       mpz_t quotient, remainder;
       mpz_t n_start;
       mpz_t n_end;

       mpz_init(n_start);
       mpz_init(n_end);
       mpz_init(quotient);
       mpz_init(remainder);

       while(1){
          found_divisor = 0;
          MPI_Bcast(&nlen, 1, MPI_INT, 0, MPI_COMM_WORLD);

          if(nlen==-1) {
             //printf("Processor %d has finished completely\n", rank);
             break;
          }

          if(rank!=0){
             nstr = (char*)malloc(nlen);
          }
       
          MPI_Bcast(nstr, (nlen+1), MPI_CHAR, 0, MPI_COMM_WORLD);
          if(rank!=0){
             mpz_set_str(n, nstr, 10);
          }
       
       
          mpz_init(n_interval);
          if(rank==0){
             mpz_t n_sqrt;
             mpz_init(n_sqrt);
             // Define limite superior para busca => sqrt(N).
             mpz_sqrt(n_sqrt, n);
   
             // Define número de iterações que cada thread deve realizar =>
             // n_interval = sqrt(N) / numero de threads.
             mpz_cdiv_q_ui(n_interval, n_sqrt, nprocs);
          
             unsigned int numeroDeDivisoresNaoAlocados = mpz_fdiv_ui (n_sqrt, nprocs);
          
             nintstr = mpz_get_str(NULL, 10, n_interval);
             nintlen = strlen(nintstr);
          }
       
          MPI_Bcast(&nintlen, 1, MPI_INT, 0, MPI_COMM_WORLD);
          if(rank!=0){
             nintstr = (char*)malloc(nintlen);
          }
       
          MPI_Bcast(nintstr, (nintlen+1), MPI_CHAR, 0, MPI_COMM_WORLD);
          if(rank!=0){
             mpz_set_str(n_interval, nintstr, 10);
          }
       
          //calculate_interval(n_interval, rank, n_start, n_end);
          //BEGIN visando otimização
          if(rank==0) {
             // O processo 0 assume o intervalo [3, n_interval].
             mpz_set_ui(n_start, 3);
             if(mpz_cmp(n_start, n_interval) >= 0)
                mpz_set(n_end, n_start);
             else
                mpz_set(n_end, n_interval);
          } else {
             // n_start = n_interval * thread.id + 1
             mpz_mul_ui(n_start, n_interval, rank);
             mpz_add_ui(n_start, n_start, 1);

             // n_end = n_interval * (thread.id + 1)
             mpz_mul_ui(n_end, n_interval, (rank + 1));
          }
          //END visando otimização

          //gmp_printf("Process: %d; Start: %Zd; End: %Zd;\n", rank, n_start, n_end);

          for(mpz_set(quotient, n_start); mpz_cmp(n_end,quotient) >= 0; mpz_add_ui(quotient, quotient, 2)) {

             if(rank==0){
                MPI_Iprobe(MPI_ANY_SOURCE, tag, MPI_COMM_WORLD, &test, &status);
                if(test){
                   MPI_Irecv(&dlen, 1, MPI_INT, MPI_ANY_SOURCE, tag, MPI_COMM_WORLD, &req);
                   if(dlen>0){
                      dstr = (char*)malloc(dlen);
                      MPI_Recv(dstr, (dlen+1), MPI_CHAR, MPI_ANY_SOURCE, tag, MPI_COMM_WORLD, &status);
                      mpz_set_str(d, dstr, 10);
                      found_divisor = 1;
                      //gmp_printf("Divisor: %Zd\n", d);
                      //gmp_printf("Divisor Length: %d\n", dlen);
                      break;
                   }else countzeros++;
                }
             }else{
                MPI_Iprobe(0, tag, MPI_COMM_WORLD, &test, &status);
                if(test){
                   MPI_Irecv(&dlen, 1, MPI_INT, MPI_ANY_SOURCE, tag, MPI_COMM_WORLD, &req);
                   if(!dlen){
                      //printf("Processor %d is finished\n", rank);
                      has_breaken = 1;
                      break;
                   }else {
                      //do nothing, IT SHOULD NOT BE DIFFERENT FROM ZERO
                   }
                }
             }
             mpz_mod(remainder, n, quotient);
             if( !mpz_sgn(remainder) ) {
                //gmp_printf("Processor %d found divisor: %Zd\n", rank, quotient);
                found_divisor = 1;
                mpz_set(d,quotient);
                if(rank==0){
                   dlen = 0;
                   for(i=1; i<nprocs; i++){
                      MPI_Isend(&dlen, 1, MPI_INT, i, tag, MPI_COMM_WORLD, &req);
                   }
                   break;
                }else {
                   dstr = mpz_get_str(NULL, 10, quotient);
                   dlen = strlen(dstr);
                   MPI_Isend(&dlen, 1, MPI_INT, 0, tag, MPI_COMM_WORLD, &req);
                   MPI_Send(dstr, (dlen+1), MPI_CHAR, 0, tag, MPI_COMM_WORLD);
                   break;
                }
             }
  
          }//for
          
          if(rank==0){
             while(countzeros<(nprocs-1)){
                MPI_Iprobe(MPI_ANY_SOURCE, tag, MPI_COMM_WORLD, &test, &status);
                if(test){
                   MPI_Irecv(&dlen, 1, MPI_INT, MPI_ANY_SOURCE, tag, MPI_COMM_WORLD, &req);
                   if(dlen>0){
                      dstr = (char*)malloc(dlen);
                      MPI_Recv(dstr, (dlen+1), MPI_CHAR, MPI_ANY_SOURCE, tag, MPI_COMM_WORLD, &status);
                      mpz_set_str(d, dstr, 10);
                      found_divisor = 1;
                      //gmp_printf("Divisor: %Zd\n", d);
                      //gmp_printf("Divisor Length: %d\n", dlen);
                      break;
                   }else countzeros++;
                }
             }
             dlen = 0;
             for(i=1; i<nprocs; i++){ //finish all remaining node
                MPI_Isend(&dlen, 1, MPI_INT, i, tag, MPI_COMM_WORLD, &req);
             }
   
             if(found_divisor && mpz_cmp(n,d)!=0){
                mpz_cdiv_q(quotient,n,d);
                mpz_set(n,quotient);
                nstr = mpz_get_str(NULL, 10, n);
                nlen = strlen(nstr);
                //gmp_printf("New Number: %Zd\n", n);
                
                node = alloc_node(sizeof(mpz_t));
                mpz_init(NODEGET( mpz_t, node ));
                mpz_set(NODEGET( mpz_t, node ), d);
                list_push_back(temp, node);

             }else{
                node = alloc_node(sizeof(mpz_t));
                mpz_init(NODEGET( mpz_t, node ));
                mpz_set(NODEGET( mpz_t, node ), n);
                list_push_back(factors, node);
                
                node = list_pop_front(temp);
                if(node) {
                   mpz_set(n, NODEGET( mpz_t, node ));
                   destroy_node(&node);
                   nstr = mpz_get_str(NULL, 10, n);
                   nlen = strlen(nstr);
                } else {
                   nlen = -1;
                }
             }
             
          }else {
             //let the master knows that the node has finished looking for a divisor
             dlen = 0;
             MPI_Isend(&dlen, 1, MPI_INT, 0, tag, MPI_COMM_WORLD, &req); 

             //if the node hasn't been broken by the master, waites for a message from the master to continue
             if(!has_breaken){
                while(1){
                   MPI_Iprobe(0, tag, MPI_COMM_WORLD, &test, &status);
                   if(test){
                      MPI_Irecv(&dlen, 1, MPI_INT, MPI_ANY_SOURCE, tag, MPI_COMM_WORLD, &req);
                      if(!dlen){
                         //printf("Processor %d is finished\n", rank);
                         break;
                      }else {
                         //do nothing, IT SHOULD NOT BE DIFFERENT FROM ZERO
                      }
                   }
                }
             }
          }
       }//while(1)
    }
    if(rank==0){
       hrt_stop(&hr_tm);
       printf("Factors: ");
       print_list(factors);
       printf("Elapsed time: %f seconds\n", hrt_elapsed_time(&hr_tm));
    }
    MPI_Finalize();
    
    return 0;
}

void calculate_interval(mpz_t n_interval, int rank, mpz_t n_start, mpz_t n_end )
{
   if(rank==0) {
      // A thread de id = 0 assume o intervalo [3, n_interval].
      mpz_set_ui(n_start, 3);
      if(mpz_cmp(n_start, n_interval) >= 0)
         mpz_set(n_end, n_start);
      else
         mpz_set(n_end, n_interval);
   } else {
      // n_start = n_interval * thread.id + 1
      mpz_mul_ui(n_start, n_interval, rank);
      mpz_add_ui(n_start, n_start, 1);

      // n_end = n_interval * (thread.id + 1)
      mpz_mul_ui(n_end, n_interval, (rank + 1));
  }
}

void random_number(mpz_t n, int numlen)
{
    char numstr[numlen+1];
    int i;

    srand( time(NULL) );

    for(i=0; i<numlen; i++) {
        numstr[i] = '0'+(rand()%10);
    }
    numstr[numlen] = 0;

    mpz_set_str(n, numstr, 10);
}

/*
 * This procedure prints all elements of the given list.
 */
void print_list(list_t *list)
{
    node_t *node = list->begin;
    while(node!=NULL) {
        gmp_printf("%Zd", NODEGET( mpz_t, node ));
        node = node->next;
        if(node)
            putchar(' ');
        else putchar('\n');
    }
}
